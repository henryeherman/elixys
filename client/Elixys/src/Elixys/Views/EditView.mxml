<?xml version="1.0" encoding="utf-8"?>
<Views:SequenceViewBase xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark" xmlns:mx="library://ns.adobe.com/flex/mx"
		xmlns:Views="Elixys.Views.*" width="100%" height="100%">
	<fx:Script>
		<![CDATA[
			import Elixys.Events.HTTPRequestEvent;
			import Elixys.HTTP.HTTPConnection;
			import Elixys.HTTP.HTTPRequest;
			import Elixys.Objects.*;
			
			import mx.collections.ArrayList;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			
			import spark.components.BorderContainer;
			import spark.components.Button;
			import spark.skins.spark.BorderContainerSkin;
			import spark.skins.spark.ButtonSkin;

			/***
			 * Member functions
			 **/
			
			// Returns the sequence insertion source and target
			public function GetSequenceInsertionSource():int
			{
				return m_nSequenceInsertionSource;
			}
			public function GetSequenceInsertionTarget():int
			{
				return m_nSequenceInsertionTarget;
			}
			
			// Update state
			public override function UpdateState(pState:State):void
			{
				// Call the base function with our type
				UpdateSequenceState(pState, StateSequence.EDITTYPE);
			}

			// Update sequence
			public override function UpdateSequence(pSequence:Sequence):void
			{
				// Don't update the sequence if the user is adding, rearranging or deleting a components
				if ((m_nSequenceInsertionSource != -1) || (m_nSequenceInsertionTarget != -1))
				{
					return;
				}

				// Update the sequence
				UpdateSequenceSequence(pSequence);

				// Request the currently selected sequence component from the server
				RequestSequenceComponent(m_nSequenceID, m_nComponentID);
			}
			
			// Update component
			public override function UpdateComponent(pComponent:Component):void
			{
				// Update the sequence component
				UpdateSequenceComponent(pComponent);
			}
			
			// Update reagent
			public override function UpdateReagents(pReagents:Array):void
			{
				// Update the sequence reagents
				UpdateSequenceReagents(pReagents);
			}
			
			// Prepares a unit operation for dragging
			private function PrepareDragObject(pContainer:DisplayObjectContainer, sLabelName:String, nX:uint, nY:uint):BorderContainer
			{
				// Get the text of the unit operation
				var pTargetLabel:Label = FindDecendentByName(pContainer, sLabelName) as Label;
				
				// Create a new object to drag
				var pLabel:Label = new Label();
				pLabel.text = pTargetLabel.text;
				pLabel.styleName = "TextMedium";
				pLabel.id = pTargetLabel.id;
				var pVGroup:VGroup = new VGroup();
				pVGroup.horizontalAlign = "center";
				pVGroup.verticalAlign = "middle";
				pVGroup.percentHeight = 100;
				pVGroup.percentWidth = 100;
				pVGroup.addElement(pLabel);
				var pBorderContainer:BorderContainer = new BorderContainer();
				pBorderContainer.id = pTargetLabel.text;
				pBorderContainer.width = 150;
				pBorderContainer.height = 40;
				pBorderContainer.x = nX - (pBorderContainer.width / 2);
				pBorderContainer.y = nY - (pBorderContainer.height / 2);
				pBorderContainer.addElement(pVGroup);
				return pBorderContainer;
			}
			
			// Determines if the given rect intersects with the target object
			private function OverlapTest(pMouseStageRect:Rectangle, pTarget:DisplayObject):Boolean
			{
				// Check if any of the four rectange corners are over the target
				var pTargetPoint:Point = pTarget.localToGlobal(new Point(0, 0));
				var pTargetRect:Rectangle = new Rectangle(pTargetPoint.x, pTargetPoint.y, pTarget.width, pTarget.height);
				return pMouseStageRect.intersects(pTargetRect);
			}

			// Locates the sequence component ID under the point
			private function FindSequenceComponentID(pStagePoint:Point):int
			{
				// Get a list of objects under the point
				var pObjectsUnderPoint:Array = getObjectsUnderPoint(pStagePoint);
				
				// Search the list for a BorderContainerSkin object
				for (var nObject:uint = 0; nObject < pObjectsUnderPoint.length; ++nObject)
				{
					var pObject:Object = pObjectsUnderPoint[nObject];
					if (pObject is BorderContainerSkin)
					{
						// Get the parent border container
						var pBorderContainerSkin:BorderContainerSkin = pObject as BorderContainerSkin;
						var pBorderContainer:BorderContainer = pBorderContainerSkin.parent as BorderContainer;
						if (pBorderContainer != null)
						{
							// Locate the child label and return the ID
							var pLabel:Label = FindDecendentByName(pBorderContainer, "_componentLabel") as Label;
							if (pLabel != null)
							{
								return parseInt(pLabel.id);
							}
						}
					}
				}
				
				// Failed to find button
				return -1;
			}

			// Locate the previous sequence component
			private function FindPreviousSequenceComponentID(nComponentID:int):int
			{
				// Iterate through our sequence list
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				var nPreviousComponentID:int = -1;
				for (var i:uint = 0; i < pArrayList.length; ++i)
				{
					var pComponent:SequenceComponent = pArrayList.getItemAt(i) as SequenceComponent;
					if (pComponent.ID == nComponentID)
					{
						// Found it.  Return the previous component ID
						return nPreviousComponentID;
					}
					else
					{
						// Remember this component ID
						nPreviousComponentID = pComponent.ID;
					}
				}
				
				// Failed to find previous component
				return -1;
			}

			// Locate the next sequence component
			private function FindNextSequenceComponentID(nComponentID:int):int
			{
				// Iterate through our sequence list
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				var bComponentFound:Boolean = false;
				for (var i:uint = 0; i < pArrayList.length; ++i)
				{
					var pComponent:SequenceComponent = pArrayList.getItemAt(i) as SequenceComponent;
					if (bComponentFound)
					{
						// This is the next component
						return pComponent.ID;
					}
					else if (pComponent.ID == nComponentID)
					{
						// Found it.  Set our flag
						bComponentFound = true;
					}
				}
				
				// Failed to find previous component
				return -1;
			}

			// Returns the last sequence component ID
			private function FindLastSequenceComponentID():int
			{
				// Get the last entry in the sequence list
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				var pComponent:SequenceComponent = pArrayList.getItemAt(pArrayList.length - 1) as SequenceComponent;
				return pComponent.ID;
			}

			// Locates the sequence component by ID
			private function FindSequenceComponentByID(nComponentID:uint):SequenceComponent
			{
				// Iterate over the sequence list
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				for (var i:uint = 0; i < pArrayList.length; ++i)
				{
					var pComponent:SequenceComponent = pArrayList.getItemAt(i) as SequenceComponent;
					if (pComponent.ID == nComponentID)
					{
						// Found it
						return pComponent;
					}
				}
				
				// Failed to find component
				throw Error("Failed to find sequence component");
			}

			// Inserts the specified component in the sequence list
			private function InsertSequenceListComponent(pNewComponent:Component, nInsertAtComponentID:int):void
			{
				// An insertion index of -1 adds to the end of the list
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				if (nInsertAtComponentID == -1)
				{
					// Found it.  Append, update and return
					pArrayList.addItem(pNewComponent);
					pArrayList.itemUpdated(pNewComponent);
					return;
				}
				
				// Search the sequence list for the component
				for (var i:uint = 0; i < pArrayList.length; ++i)
				{
					var pComponent:SequenceComponent = pArrayList.getItemAt(i) as SequenceComponent;
					if (pComponent.ID == nInsertAtComponentID)
					{
						// Found it.  Insert, update and return
						pArrayList.addItemAt(pNewComponent, i);
						pArrayList.itemUpdated(pNewComponent);
						return;
					}
				}
				
				// Component not found
				throw Error("Sequence component not found");
			}

			// Updates the specified component in the sequence list
			private function UpdateSequenceListComponent(nComponentID:uint):void
			{
				// Search the sequence list for the component
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				for (var i:uint = 0; i < pArrayList.length; ++i)
				{
					var pComponent:SequenceComponent = pArrayList.getItemAt(i) as SequenceComponent;
					if (pComponent.ID == nComponentID)
					{
						// Found it.  Update and return
						pArrayList.itemUpdated(pArrayList.getItemAt(i));
						return;
					}
				}
				
				// Component not found
				throw Error("Sequence component not found");
			}

			// Removes the specified component in the sequence list
			private function RemoveSequenceListComponent(nComponentID:uint):void
			{
				// Search the sequence list for the component
				var pArrayList:ArrayList = _sequenceList.dataProvider as ArrayList;
				for (var i:uint = 0; i < pArrayList.length; ++i)
				{
					var pComponent:SequenceComponent = pArrayList.getItemAt(i) as SequenceComponent;
					if (pComponent.ID == nComponentID)
					{
						// Found it.  Remove and return
						pArrayList.removeItem(pComponent);
						return;
					}
				}
				
				// Component not found
				throw Error("Sequence component not found");
			}

			// Update the insertion target in the sequence list
			protected function UpdateSequenceInsertionTarget(nNewInsertionTargetID:int):void
			{
				// Close any existing gap
				if (m_nSequenceInsertionTarget != -1)
				{
					var nOldInsertionTarget:int = m_nSequenceInsertionTarget;
					m_nSequenceInsertionTarget = -1;
					UpdateSequenceListComponent(nOldInsertionTarget);
				}
				
				// Create a new gap
				if (nNewInsertionTargetID != -1)
				{
					m_nSequenceInsertionTarget = nNewInsertionTargetID;
					UpdateSequenceListComponent(m_nSequenceInsertionTarget);
				}
			}

			// Clear the drag variables
			protected function CleanUpDrag():void
			{
				m_pMouseDownTarget = null;
				m_pDragObject = null;
				m_nSequenceInsertionSource = -1;
				m_nSequenceInsertionTarget = -1;
				m_bTrashCanTarget = false;
				SetTrashCan();
			}
			
			// Sets the state of the trash can
			protected function SetTrashCan():void
			{
				_trashCanBorder.setStyle("backgroundColor", m_bTrashCanTarget ? "0x000000" : "0xffffff");
			}
			
			/***
			 * Message handlers
			 **/
			
			// Called when creation is complete
			protected override function OnCreationComplete(event:FlexEvent):void
			{
				// Call the base implementation
				super.OnCreationComplete(event);

				// Set our view mode
				m_sViewMode = SubviewBase.EDITMODE;
				
				// Set the base class variables
				m_pOnButtonClick = OnButtonClick;
				m_pUnitOperationsList = _unitOperationList;
				m_pSequenceName = _sequenceName;
				m_pSequenceList = _sequenceList;
				m_pNavigationButtons = _navigationButtons;
				m_pComponentGroup = _componentGroup;
				
				// Create the timers
				m_pUnitOperationMouseTimer = new Timer(200, 1);
				m_pUnitOperationMouseTimer.addEventListener(TimerEvent.TIMER, OnUnitOperationMouseDownTimer);
				m_pComponentMouseTimer = new Timer(200, 1);
				m_pComponentMouseTimer.addEventListener(TimerEvent.TIMER, OnComponentMouseDownTimer);
				
				// Add mouse event listeners to the stage for dragging and dropping
				stage.addEventListener(MouseEvent.MOUSE_UP, OnMouseUp);
				stage.addEventListener(MouseEvent.MOUSE_MOVE, OnMouseMouse);
			}

			// Mouse button up and movement message handdlers
			public function OnMouseUp(event:MouseEvent):void
			{
				// Call the appropriate handler depending on our dragging state
				if (m_bDraggingNewUnitOperation)
				{
					OnNewUnitOperationMouseUp(event);
				}
				else if (m_bDraggingInsertComponent)
				{
					OnInsertComponentMouseUp(event);
				}
			}
			public function OnMouseMouse(event:MouseEvent):void
			{
				// Are we dragging?
				if (m_bDraggingNewUnitOperation || m_bDraggingInsertComponent)
				{
					// Update the position of the drag object
					m_pDragObject.move(event.stageX - 75, event.stageY - 20);
					
					// Check if we are over the sequence list
					var pDragRectangle:Rectangle = new Rectangle(event.stageX - 75, event.stageY - 20, 150, 40);
					var nOldInsertionTarget:int;
					if (OverlapTest(pDragRectangle,_sequenceList))
					{
						// Determine the ID of the upper and lower sequence components by hit test
						var pSequenceListPoint:Point = _sequenceList.localToGlobal(new Point(_sequenceList.width / 2, 0));
						var nUpperComponentID:int = FindSequenceComponentID(new Point(pSequenceListPoint.x, event.stageY - 20));
						var nLowerComponentID:int = FindSequenceComponentID(new Point(pSequenceListPoint.x, event.stageY + 20));
						
						// Try and find the upper component ID if we didn't get one by hit test
						if (nUpperComponentID == -1)
						{
							// Do we have a lower component ID?
							if (nLowerComponentID != -1)
							{
								// Yes, so find the ID the the upper component
								nUpperComponentID = FindPreviousSequenceComponentID(nLowerComponentID);
							}
							else
							{
								// No, but since we know we are over the sequence list we can safely assume that we are at the end of the list
								nUpperComponentID = FindLastSequenceComponentID();
							}
						}
						
						// Try and find the lower component ID if we didn't get one by hit test
						if (nLowerComponentID == -1)
						{
							// Do we have an upper component ID?
							if (nUpperComponentID != -1)
							{
								// Yes, so find the ID the the lower component
								nLowerComponentID = FindNextSequenceComponentID(nUpperComponentID);
							}
						}
						
						// Determine the lower component type
						if (nLowerComponentID != -1)
						{
							var pComponent:SequenceComponent = FindSequenceComponentByID(nLowerComponentID);
							if (pComponent.ComponentType == ComponentCassette.TYPE)
							{
								// Do not allow the user to insert before a cassette
								nUpperComponentID = -1;
							}
						}
						
						// Has the insertion target changed?
						if (nUpperComponentID != m_nSequenceInsertionTarget)
						{
							// Yes, so update the sequence list
							UpdateSequenceInsertionTarget(nUpperComponentID);
						}
					}
					else
					{
						// We are not over the sequence list, so remove any insertion gap
						UpdateSequenceInsertionTarget(-1);
					}
					
					// Are we dragging an existing unit operation?
					if (m_nSequenceInsertionSource != -1)
					{
						// Yes, so set the trash can background color based on our position
						m_bTrashCanTarget = OverlapTest(pDragRectangle, _trashCan);
						SetTrashCan();
					}
				}
			}

			// Unit operation message handlers
			public function OnUnitOperationMouseDown(event:MouseEvent):void
			{
				// Remember the mouse down target
				m_pMouseDownTarget = event.target as DisplayObjectContainer;
				
				// Set the timer so we can determine if this is a click or drag
				if (!m_pUnitOperationMouseTimer.running)
				{
					m_pUnitOperationMouseTimer.start();
				}
			}
			public function OnUnitOperationMouseUp(event:MouseEvent):void
			{
				// Is our timer still running?
				if (m_pUnitOperationMouseTimer.running)
				{
					// Yes, so stop it
					m_pUnitOperationMouseTimer.stop();
					
					// Determine what unit operation the user clicked on and handle it
					var pLabel:Label = FindDecendentByName(m_pMouseDownTarget, "_unitOperationLabel") as Label;
					trace("Handle component click: " + pLabel.text);
				}

				// Clear the drag variables
				CleanUpDrag();
			}
			protected function OnUnitOperationMouseDownTimer(event:TimerEvent):void
			{
				// Prepare to drag
				m_pDragObject = PrepareDragObject(m_pMouseDownTarget, "_unitOperationLabel", mouseX, mouseY);
				addElement(m_pDragObject);
				
				// Start dragging.  The build-in startDrag() and stopDrag() functions stopped working after upgrading to AIR 2.7 so we're
				// doing this manually for the moment
				m_bDraggingNewUnitOperation = true;
				
				// Clear our target
				m_pMouseDownTarget = null;
			}
			public function OnNewUnitOperationMouseUp(event:MouseEvent):void
			{
				// Stop the dragging and remove the object
				m_bDraggingNewUnitOperation = false;
				removeChild(m_pDragObject);
				
				// Perform any require action
				if (m_nSequenceInsertionTarget != -1)
				{
					// Insert the unit operation
					InsertUnitOperation(m_pDragObject.id, m_nSequenceInsertionTarget);
					
					// Close the insertion gap
					UpdateSequenceInsertionTarget(-1);
				}
				
				// Clear the drag variables
				CleanUpDrag();
			}

			// Component message handlers
			public function OnComponentMouseDown(event:MouseEvent):void
			{
				// Remember the mouse down target
				m_pMouseDownTarget = event.target as DisplayObjectContainer;
				
				// Set the timer so we can determine if this is a click or drag
				if (!m_pComponentMouseTimer.running)
				{
					m_pComponentMouseTimer.start();
				}
			}
			public function OnComponentMouseUp(event:MouseEvent):void
			{
				// Is our timer still running?
				if (m_pComponentMouseTimer.running)
				{
					// Yes, so stop it
					m_pComponentMouseTimer.stop();
					
					// Determine what unit operation the user clicked on
					var pLabel:Label = FindDecendentByName(m_pMouseDownTarget, "_componentLabel") as Label;
					
					// Create a POST request
					var pPostSequence:PostSequence = new PostSequence();
					pPostSequence.TargetID(pLabel.id);
					
					// Pass the request to the server
					DoPost(pPostSequence, "EDIT");
				}
				
				// Clear the drag variables
				CleanUpDrag();
			}
			protected function OnComponentMouseDownTimer(event:TimerEvent):void
			{
				// Determine what type of sequence component the user is attempting to drag
				var pLabel:Label = FindDecendentByName(m_pMouseDownTarget, "_componentLabel") as Label;
				var pComponent:SequenceComponent = FindSequenceComponentByID(parseInt(pLabel.id));
				if (pComponent.ComponentType == ComponentCassette.TYPE)
				{
					// Do not allow the user to move a cassette
					CleanUpDrag();
					return;
				}

				// Prepare to drag
				m_pDragObject = PrepareDragObject(m_pMouseDownTarget, "_componentLabel", mouseX, mouseY);
				addElement(m_pDragObject);
				
				// Start dragging.  See note in OnUnitOperationMouseDownTimer()
				m_bDraggingInsertComponent = true;
				m_nSequenceInsertionSource = pComponent.ID;
				
				// Locate the previous component ID and create an initial gap for the newly dislocated component
				var nPreviousComponentID:int = FindPreviousSequenceComponentID(m_nSequenceInsertionSource);
				UpdateSequenceInsertionTarget(nPreviousComponentID);

				// Remove the old element and clear our target
				RemoveSequenceListComponent(m_nSequenceInsertionSource);
				m_pMouseDownTarget = null;
			}
			public function OnInsertComponentMouseUp(event:MouseEvent):void
			{
				// Stop the dragging and remove the object
				m_bDraggingInsertComponent = false;
				removeChild(m_pDragObject);
				
				// Perform any require action
				if (m_nSequenceInsertionSource != -1)
				{
					if (m_bTrashCanTarget)
					{
						// Delate the component
						OnSequenceComponentDelete();
					}
					else if (m_nSequenceInsertionTarget != -1)
					{
						// Move the component
						OnSequenceComponentMove();
					}
					else
					{
						// Update the state to restore the component
						RequestSequence(m_nSequenceID);
					}
				}
				
				// Clear the drag variables
				CleanUpDrag();
			}
			
			// Called when the user moves an existing sequence component
			protected function OnSequenceComponentMove():void
			{
				// Post the component to the server
				DoPost(null, "sequence/" + m_nSequenceID + "/component/" + m_nSequenceInsertionSource + "/" + m_nSequenceInsertionTarget);
				
				// Close the insertion gap
				UpdateSequenceInsertionTarget(-1);
			}

			// Called when the user deletes an existing sequence component
			protected function OnSequenceComponentDelete():void
			{
				// Delete the component from the server
				DoDelete("sequence/" + m_nSequenceID + "/component/" + m_nSequenceInsertionSource);
				
				// Close the insertion gap
				UpdateSequenceInsertionTarget(-1);
			}

			// Button click handler
			public override function OnButtonClick(event:MouseEvent):void
			{
				// Create a POST request
				var pPostSequence:PostSequence = new PostSequence();
				pPostSequence.TargetID((event.target as spark.components.Button).id);
				
				// Pass the request to the server
				DoPost(pPostSequence, "EDIT");
			}
			
			/***
			 * Member variables
			 **/
			
			// Dragging variables
			private var m_bDraggingNewUnitOperation:Boolean = false;
			private var m_bDraggingInsertComponent:Boolean = false;
			private var m_pDragObject:BorderContainer = null;
			
			// Sequence insertion source and target
			private var m_nSequenceInsertionSource:int = -1;
			private var m_nSequenceInsertionTarget:int = -1;
			private var m_bTrashCanTarget:Boolean = false;

			// Mouse down target
			private var m_pMouseDownTarget:DisplayObjectContainer = null;

			// Timers
			private var m_pUnitOperationMouseTimer:Timer;
			private var m_pComponentMouseTimer:Timer;
		]]>
	</fx:Script>
	
	<s:HGroup horizontalAlign="center" verticalAlign="middle" horizontalCenter="0" verticalCenter="0" paddingLeft="20"
			paddingRight="20" paddingTop="20" paddingBottom="20" width="100%" height="100%">
		<s:VGroup horizontalAlign="center" verticalAlign="middle" horizontalCenter="0" verticalCenter="0" height="100%">
			<s:Label styleName="TextMedium" text="Toolbox" />
			<s:List id="_unitOperationList" height="100%">
				<s:itemRenderer>
					<fx:Component>
						<s:ItemRenderer autoDrawBackground="false">
							<fx:Script>
								<![CDATA[
									// Formats the label text
									override public function set data(value:Object):void
									{
										super.data = value;
										if (value != null)
										{
											_unitOperationLabel.text = value as String;
										}
									}
								]]>
							</fx:Script>
							<s:states>
								<s:State name="normal" />
								<s:State name="hovered" />
								<s:State name="selected" />
							</s:states>
							<s:VGroup paddingLeft="10" paddingRight="10" paddingTop="7" paddingBottom="7">
								<s:BorderContainer mouseDown="outerDocument.OnUnitOperationMouseDown(event)"
										mouseUp="outerDocument.OnUnitOperationMouseUp(event)"
										width="150" height="40">
									<s:VGroup horizontalAlign="center" verticalAlign="middle" width="100%" height="100%">
										<s:Label id="_unitOperationLabel" name="_unitOperationLabel" styleName="TextMedium" />
									</s:VGroup>
								</s:BorderContainer>
							</s:VGroup>
						</s:ItemRenderer>
					</fx:Component>
				</s:itemRenderer>
			</s:List>
			<s:VGroup horizontalAlign="center" verticalAlign="middle" horizontalCenter="0" verticalCenter="0" height="150">
				<s:BorderContainer id="_trashCanBorder">
					<s:Image id="_trashCan" source="@Embed(source='trashcan.png')" x="2" y="2" width="150" height="100" />
				</s:BorderContainer>
			</s:VGroup>
		</s:VGroup>
		<s:VGroup horizontalAlign="center" verticalAlign="middle" horizontalCenter="0" verticalCenter="0" height="100%">
			<s:Label id="_sequenceName" styleName="TextMedium" text="" />
			<s:List id="_sequenceList" requireSelection="true" height="100%">
				<s:itemRenderer>
					<fx:Component>
						<s:ItemRenderer autoDrawBackground="false">
							<fx:Script>
								<![CDATA[
									// Formats the button text
									override public function set data(value:Object):void
									{
										// Set the base class data
										super.data = value;
										
										if (value != null)
										{
											// Set the background color
											if (outerDocument.GetComponentID() == data.ID)
											{
												_componentContainer.setStyle("backgroundColor", "0xbbbbbb");
											}
											else
											{
												_componentContainer.setStyle("backgroundColor", "0xffffff");
											}
											
											// Format the button text
											_componentLabel.text = ""
											if (data.DisplayIndex != 0)
											{
												_componentLabel.text = data.DisplayIndex + ". ";
											}
											_componentLabel.text += data.Name;
											_componentLabel.id = data.ID;
										
											// Show or hide the insertion point
											var bInsertionPoint:Boolean = (outerDocument.GetSequenceInsertionTarget() == data.ID);
											_insertionSpacer.visible = bInsertionPoint;
											_insertionSpacer.includeInLayout = bInsertionPoint;
										}
									}
								]]>
							</fx:Script>
							<s:states>
								<s:State name="normal" />
								<s:State name="selected" />
							</s:states>
							<s:VGroup paddingLeft="10" paddingRight="10" paddingTop="7" paddingBottom="7">
								<s:BorderContainer id="_componentContainer" mouseDown="outerDocument.OnComponentMouseDown(event)" 
										mouseUp="outerDocument.OnComponentMouseUp(event)" width="150" height="40">
									<s:VGroup horizontalAlign="center" verticalAlign="middle" width="100%" height="100%">
										<s:Label id="_componentLabel" name="_componentLabel" styleName="TextMedium" />
									</s:VGroup>
								</s:BorderContainer>
								<s:Spacer id="_insertionSpacer" visible="false" includeInLayout="false" width="100%" height="15" />
							</s:VGroup>
						</s:ItemRenderer>
					</fx:Component>
				</s:itemRenderer>
			</s:List>
		</s:VGroup>
		<s:VGroup horizontalAlign="right" verticalAlign="middle" gap="20" width="100%" height="100%">
			<s:HGroup id="_navigationButtons" gap="20" />
			<s:Button id="PREVIOUS" label="Previous" styleName="button" click="OnButtonClick(event)" width="100%" height="40" />
			<s:VGroup id="_componentGroup" width="100%" height="100%" />
			<s:Button id="NEXT" label="Next" styleName="button" click="OnButtonClick(event)" width="100%" height="40" />
		</s:VGroup>
	</s:HGroup>
</Views:SequenceViewBase>
